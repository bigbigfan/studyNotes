<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>const && let of ES5</title>
  </head>
  <body></body>
  <script>
    //  =================================== const ========================================================
    // 由于es5不存在block概念 无法完全实现const 只能是挂到某个对象下，要么是全局的window要么就是自定义一个object当容器

    // var __const = function __const(data, value) {
    //   window.data = value; // 把要定义的data挂载到window下，并赋值value
    //   Object.defineProperty(window, data, {
    //     // 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符
    //     enumerable: false,
    //     configurable: false,
    //     get: function () {
    //       return value;
    //     },
    //     set: function (data) {
    //       //  const 对于引用类型其实是可以修改其具体内容的，因为const只是保证了指向该引用类型的地址不变，无法保证引用类型内容不变
    //       //  所以通过区分两个值不同 和原类型非引用类型来判断是否可以修改值
    //       if (value !== data || typeof value !== "object") {
    //         throw new TypeError("Assignment to constant variable.");
    //       } 
    //       return data
    //     },
    //   });
    // };
    // __const("a", [1, 2 , 3]);
    // console.log(a);
    // a[0] = 3
    // console.log(a);


    //  =================================== let ========================================================
    

    //  (function () {
    //     var a = 1
    //     console.log(a);
    //  })()

    // {
    //   var a = 1
    //   let b = 2
    //   console.log(b);
    // }
  
    //  console.log(a); // 1
    //  console.log(b); // b is not defined  因为let是块级
     
    // 实现一个let 借助闭包
    
    // {
    //   (function() {
    //        var c = 1
    //   })()
    //   console.log(c); // 那我在这里不是一样访问不到c 。。。
    // }
    // console.log(c); // 确实访问不到

    //  var a = 0
    //  if(true) {
    //    a = 1
    //    function a () {}
    //    a = 21
    //    console.log('里面', a); // 21
    //  }
    //  console.log('外面', a); // 1

    // if 的函数作为一个块级作用域 内部预编译时function会被提升 如下

    // if(true) {
    //     var a = function () {} // 声明了a 是function 
    //     a = 1 // 修改该作用域内部的a === 1
    //     a = 21// 修改该作用域内部的a === 21
    // } 
    //  所以外部的全局变量 var a = 0 并不受影响 未被修改
   
    //  另一个现象
    var name = 1 
    console.log(window.name); // 1
    let age = 2
    console.log(window.age); // undefined 显然 let声明不会挂到window上
  </script>
</html>
