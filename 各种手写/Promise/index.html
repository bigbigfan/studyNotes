<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    // Promise/A+ 规范的三种状态
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

class MyPromise {
   // 构造方法接受一个回调
   constructor(executor) {
       this._status = PENDING // Promise 状态默认设置成pending
       this._resolveQueue = [] // 成功队列，resolve触发
       this._rejectQueue = [] // 失败队列，reject触发
     // 由于resolve/reject 是在executor内部被调用，因此需要使用箭头函数固定this指向，否则找不到this._resolveQueue  
       let _resolve = (val) => {
          if(this._status !== PENDING) return // 对应规范中的"状态只能由pending到fulfilled或rejected
          this._status = FULFILLED // 变更状态

          // 这里之所以用一个队列储存回调，是为了实现规范要求的then方法可以被同一个Promise调用多次
          // 如果使用一个变量而非队列来储存回调，那么及时多次p1.then()也只会执行一次回调
           
            while(this._resolveQueue.length) {
                const callback = this._resolveQueue.shift() // 队列是先进先出的和排队打饭一样
                callback(val)
            }
       }
       //实现reject
       let _reject = (val) => {
           if(this._status !== PENDING) return // // 对应规范中的"状态只能由pending到fulfilled或
           this._status = REJECTED // 变更状态
          
           while(this._rejectQueue.length) {
               const callback = this._rejectQueue.shift() 
               callback(val)
           }
        }  
       //  new Promise()时立即执行executor 并传入resolve和reject
        executor(_resolve, _reject)    
    }
   
    // then方法，接受一个成功的回调和一个失败的回调
    then(resolveFn, rejectFn) {
        // return 一个新的promise
        return new MyPromise((resolve, reject) => {
         // 把resolveFn 重新包装一下，再push进resolve执行队列，这是为了能够获取回调的返回值进行分类讨论
            const fulfilledFn = value => {
               try {
            //   执行第一个（当前的）Promise的成功回调，并获取返回值
               let x = resolveFn(value)
            //  分类讨论返回值，如果是Promise那么等待Promise状态变更 否则直接resolve
            // 这里resolve 之后，就能被下一个.then()的回调获取到返回值，从而实现链式调用
               x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
              } catch(error) {
                 reject(error)
              }
            }
        //   把后续then收集的依赖都push进当前Promise的成功回调队列中 为了保证顺序调用
           this._resolveQueue.push(fulfilledFn)
         
           // reject    
          const rejectedFn = error => {
              try {
                  let x = rejectFn(error)
                  x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
              } catch(error) {
                  reject(error)
              }
            }
            this._rejectQueue.push(rejectedFn)
        })
    }
}

const p1 = new MyPromise((resolve, reject) => {
    setTimeout(() => {
    resolve(1) 
    }, 500);
})

p1
.then(res => {
    console.log(res)
    return 2
})
.then(res => {
    console.log(res)
    return 3
})
.then(res => {
    console.log(res);
})

</script>
</html>