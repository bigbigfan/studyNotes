<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    function showPosition(e) {
      console.log("position", e.clientX, new Date());
    }

    // 防抖
    // function debounce (fn, delay) {
    //     let timer
    //     return (...args) => {
    //         clearTimeout(timer)
    //         timer = setTimeout(() => {
    //             // fn.apply(this, arguments)
    //             fn(...args)
    //         }, delay);
    //     }
    // }

    // 定时器法节流
    // function throttle1(fn, delay) {
    //   let timer;
    //   let isFirst = true;
    //   return (...args) => {
    //     // let context = this;
    //     // let args = arguments;
    //     if (isFirst) {
    //         console.log('321',this);
    //     //   fn.apply(this, arguments);
    //       fn(...args)
    //       isFirst = false
    //     }
    //     if (!timer) {
    //      timer = setTimeout(() => {
    //         timer = null;
    //         // fn.apply(this, arguments);
    //         fn(...args)
    //       }, delay);
    //     }
    //   };
    // }
    // 时间戳法节流
    // function throttle2(fn, delay) {
    //   //  初始化时间戳
    //   let previous = Date.now();
    //   let isFirst = true;
    //   return (...args) => {
    //     if (isFirst) {
    //       fn(...args);
    //       isFirst = false;
    //     }
    //     const now = Date.now();
    //     //  如果现在的时间戳-先前的时间戳的差比 delay时间大就执行函数
    //     //  且重置时间戳
    //     if (now - previous >= delay) {
    //       fn(...args);
    //       previous = Date.now();
    //     }
    //   };
    // }

    function throttle1(fn, delay) {
      let timer, isFirst = true
      return (...args) => {
         if(isFirst) {
           fn(...args)
           isFirst = false
         }
         if(!timer) {
           timer = setTimeout(() => {
            timer = null
            fn(...args)
           }, delay);
         }
      }
    }

// ==================1-7 忘了就写一次====================== 
    // function throttle2(fn ,delay) {
    //    let previous = 0 // 取0就是马上会执行一次
    //    return (...args) => {
    //        const now = Date.now()
    //        if(now - previous >= delay) {
    //               fn(...args)
    //               previous = now
    //        }
    //    }
    // }


    // function throttle1(fn, delay) {
    //      let timer, isFirst = true
    //      return (...args) => {
    //         if(isFirst) {
    //           fn(...args)
    //           isFirst = false
    //         } 
    //         if(!timer) {
    //            timer = setTimeout(() => {
    //             fn(...args)
    //             timer = null
    //            }, delay)
    //         }
    //      } 
    // }
// =======================================================
    
    window.onmousemove = throttle1(showPosition, 2000);
  </script>
</html>
